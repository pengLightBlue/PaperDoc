# 滑动窗口思想

## Leetcode原题

### [209]长度最小的子数组

#### 题目

```
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
提示：

1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104
```

#### 讲解

* 应用滑动窗口的思想，固定字符串的右端点，判断当前窗口的子串是否符合条件
  * 符合条件：通过右移left缩小窗口大小，进一步判断子串是否符合条件
  * 不符合：右移right进行判断

#### 代码实现

```go
//leetcode submit region begin(Prohibit modification and deletion)
func minSubArrayLen(target int, nums []int) int {
	n := len(nums)
	// res默认比nums的长度+1，如果是n的话，会误以为找到的子数组就是整个nums
    res, sum, left := n+1, 0, 0
	// 定位右端点
	for right, val := range nums {
		sum += val

		// 因为要找的符合>=target的最小子数组，那么在符合条件的情况下，通过缩小左边的窗口来进一步过滤
		for sum - nums[left] >= target {
			sum -= nums[left]
			left++
		}

		// 可能存在sum值不符合条件的情况，所以得满足条件才判断res值
		if sum >= target {
			// right-left是否要+1，可通过一些特殊值判断
			// 比如left=right的情况，这个子数组只有一个元素但符合条件，所以要+1
			res = min(res, right-left+1)
		}
	}

	// res值得进行特殊判断，因为得小于等于n才证明找到了子数组
	if res <= n {
		return res
	}
	// 找不到的情况下返回0
	return 0
}
//leetcode submit region end(Prohibit modification and deletion)
```

#### 复杂度分析

* 时间复杂度：O(n)，其中 n 为 nums 的长度。虽然写了个二重循环，但是内层循环中对 left 加一的总执行次数不会超过 n 次，所以总的时间复杂度为 O(n)。
* 空间复杂度：O(1)，仅用到若干额外变量。

### [76]最小覆盖子串

#### 题目

```
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
示例 2：

输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
提示：

m == s.length
n == t.length
1 <= m, n <= 105
s 和 t 由英文字母组成
```

#### 讲解

**什么是「涵盖」**

* 看示例 1，s 的子串 BANC 中每个字母的出现次数，都大于等于 t=ABC 中每个字母的出现次数，这就叫涵盖。

**滑动窗口怎么滑**

* 原理和 209 题一样，按照视频中的做法，我们枚举 s 子串的右端点 right（子串最后一个字母的下标），如果子串涵盖 t，就不断移动左端点 left 直到不涵盖为止。在移动过程中更新最短子串的左右端点。

具体来说：

1.  初始化 ansLeft\=−1, ansRight\=m，用来记录最短子串的左右端点，其中 m 是 s 的长度。
2.  用一个哈希表（或者数组）cntT 统计 t 中每个字母的出现次数。
3.  初始化 left\=0，以及一个空哈希表（或者数组）cntS，用来统计 s 子串中每个字母的出现次数。
4.  遍历 s，设当前枚举的子串右端点为 right，把 s\[right\] 的出现次数加一。
5.  遍历 cntS 中的每个字母及其出现次数，如果出现次数都大于等于 cntT 中的字母出现次数：
    1.  如果 right−left<ansRight−ansLeft，说明我们找到了更短的子串，更新 ansLeft\=left, ansRight\=right。
    2.  把 s\[left\] 的出现次数减一。
    3.  左端点右移，即 left 加一。
    4.  重复上述三步，直到 cntS 有字母的出现次数小于 cntT 中该字母的出现次数为止。
6.  最后，如果 ansLeft<0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。

由于本题大写字母和小写字母都有，为了方便，代码实现时可以直接创建大小为 128 的数组，保证所有 ASCII 字符都可以统计。

#### 代码

```go
//leetcode submit region begin(Prohibit modification and deletion)
func minWindow(s string, t string) string {
	// 初始化结果子串左右结果值
    resLeft, resRight := -1, len(s)

	var countT, countS [128]int
	for _, c := range t {
		countT[c]++
	}

	left := 0
	// 固定s子串右端点
	for right, c := range s {
		countS[c]++

		// 判断是否涵盖
		for isCover(countS[:], countT[:]) {
			// 判断是否为更小的子串，是的话进行赋值
			if right - left < resRight - resLeft {
				resLeft, resRight = left, right
			}
			// 移动left，缩小窗口，找到符合条件的最小子串
			countS[s[left]]--
			left++
		}
	}

	if resLeft < 0 {
		return ""
	}

	// 是否要+1，当resRight=resLeft的时候，+1才可以将字符包含进去
	return s[resLeft:resRight+1]
}

// 判断s数组里面字符出现的次数是否涵盖t数组里的
func isCover(s, t []int) bool {
	// a-z，记得都包含进去
	for i := 'a'; i <= 'z'; i++ {
		if s[i] < t[i] {
			return false
		}
	}

	// A-Z，记得都包含进去
	for i := 'A'; i <= 'Z'; i++ {
		if s[i] < t[i] {
			return false
		}
	}

	return true
}
//leetcode submit region end(Prohibit modification and deletion)
```

#### 复杂度分析

-   时间复杂度：O(∣Σ∣m+n)，其中 m 为 s 的长度，n 为 t 的长度，∣Σ∣ 为字符集合的大小，本题字符均为英文字母，所以 ∣Σ∣\=52。注意 left 只会增加不会减少，left 每增加一次，我们就花费 O(∣Σ∣) 的时间。因为 left 至多增加 m 次，所以二重循环的时间复杂度为 O(∣Σ∣m)，再算上统计 t 字母出现次数的时间 O(n)，总的时间复杂度为 O(∣Σ∣m+n)。
-   空间复杂度：O(∣Σ∣)。如果创建了大小为 128 的数组，则 ∣Σ∣\=128。